# Design of `x86-alignment-check`

## 1. Overview

The `x86-alignment-check` library provides a minimal, `no_std` interface to control the Alignment Check (AC) flag on x86 and x86_64 architectures. This allows developers to enable or disable alignment checking for specific sections of their code, which is useful for debugging and testing memory access patterns.

## 2. Architecture

The library is implemented as a single Rust file, `src/lib.rs`, with no external dependencies. It uses conditional compilation (`#[cfg]`) to provide architecture-specific implementations for `x86` and `x86_64`.

## 3. Components

### 3.1. `x86_alignment_check(b: bool) -> bool`

*   **Purpose:** Directly enables or disables the AC flag.
*   **Implementation:**
    *   Reads the current `eflags` (x86) or `rflags` (x86_64) register using inline assembly (`core::arch::asm!`).
    *   Sets or clears the AC bit (bit 18) based on the boolean parameter `b`.
    *   Writes the modified value back to the register.
    *   Returns a boolean indicating the *previous* state of the AC flag.
*   **Conditional Compilation:** This function, and its helper functions, are only compiled for `target_arch = "x86"` or `target_arch = "x86_64"`.

### 3.2. `ac_call_once<F, T>(f: F) -> T`

*   **Purpose:** Executes a closure with the AC flag enabled, ensuring the original flag state is restored.
*   **Implementation:**
    1.  Calls `x86_alignment_check(true)` to enable the AC flag and stores the original state.
    2.  Executes the provided closure `f`.
    3.  Calls `x86_alignment_check()` with the original state to restore it.
    4.  Returns the result of the closure.

### 3.3. `no_ac_call_once<F, T>(f: F) -> T`

*   **Purpose:** Executes a closure with the AC flag disabled, ensuring the original flag state is restored.
*   **Implementation:**
    1.  Calls `x86_alignment_check(false)` to disable the AC flag and stores the original state.
    2.  Executes the provided closure `f`.
    3.  Calls `x86_alignment_check()` with the original state to restore it.
    4.  Returns the result of the closure.

### 3.4. Constants and Helper Functions

*   `EFLAGS_AC_BIT`: A constant defining the bitmask for the AC flag ( `1 << 18`). It is defined as `u32` for x86 and `u64` for x86_64.
*   `__read_eflags()`: An `unsafe` inline function to read the `eflags`/`rflags` register.
*   `__write_eflags()`: An `unsafe` inline function to write to the `eflags`/`rflags` register.

## 4. `no_std` Compatibility

The library achieves `no_std` compatibility by:

*   Using the `#![no_std]` attribute at the crate root.
*   Relying only on `core` library features, specifically `core::arch::asm!` for hardware interaction.

## 5. Testing Strategy

The design includes a `#[cfg(test)]` module with unit tests:

*   **`it_works_0`:** Tests the basic functionality of `x86_alignment_check`, ensuring it correctly sets, unsets, and returns the previous state of the AC flag.
*   **`it_works_1` and `it_works_2`:** Verify that `ac_call_once` and `no_ac_call_once` execute their closures and return the correct values.
*   **`it_works_3`:** A more complex test demonstrating nested calls and safe unaligned access within a `no_ac_call_once` block.
*   **`it_works_ignore_0`:** A test designed to cause a `SIGBUS` fault by performing an unaligned memory access while the AC flag is enabled. This test is marked `#[ignore]` to prevent it from running during normal test execution, as it is expected to crash the program.
